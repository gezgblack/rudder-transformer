bindings:
  - path: ../../../v0/util
  - path: ../../../v0/destinations/webhook/utils
  - path: ../../../constants
steps:
  - name: validateInput
    template: |
      (
        $assert(destination.Config.webhookUrl or false, "Invalid URL in destination config");
        $assert($exists(message.type), "message Type is not present. Aborting message.");
      )
  - name: buildHeaderBlock
    template: |
      (
        $defaultHeaders := destination.Config.webhookMethod in ['POST', 'PUT', 'PATCH'] or $not($exists(destination.Config.webhookMethod)) ? {"content-type": "application/json"};
        $finalHeaders := $merge([$defaultHeaders, $getHashFromArray(destination.Config.headers)]);
        $messageHeader := $type(message.header) = "object" ? message.header : {};
        $finalHeaders := $merge([$finalHeaders, $sift($messageHeader, function($v){(
          $type($v) = "string"
          )})]);
        $setContext("finalHeaders", $finalHeaders);
      )
  - name: deduceEndPoint
    template: |
      (
        $integrationsObjects := $getIntegrationsObj(message, "webhook");
        $defaultEndpoint := destination.Config.webhookUrl;
        $finaleEndpoint := [ message.fullPath , $integrationsObjects.fullPath, $defaultEndpoint ][0];
        $messageAppendPath := [ message.appendPath, $integrationsObjects.appendPath ][0];
        $finaleEndpoint := $finaleEndpoint & $messageAppendPath;
        $setContext("finaleEndpoint", $finaleEndpoint)
      )
  - name: processForGETANDDELETEMethod
    condition: destination.Config.webhookMethod = 'GET' or destination.Config.webhookMethod = 'DELETE'
    template: |
      (
       $response := { 
        "method" : destination.Config.webhookMethod,
        "params" : $getPropertyParams(message)
      };
      $setContext("payload", $response);
      )
     
  - name: processPOSTPUTPATCHMethod
    condition: destination.Config.webhookMethod = 'POST' or destination.Config.webhookMethod = 'PUT' or destination.Config.webhookMethod = 'PATCH' or $not($exists(destination.Config.webhookMethod))
    template: |
      (
      $contextObj := message.context;
       $req_ip := message.request_ip;
       $abc := message.context.ip? message.context : $merge([message.context, {"ip": message.request_ip}]);
       $contextObj := message.{
            "context": $abc
        };
      $response := {
        "method" : destination.Config.webhookMethod,
        "body": $merge([message ~> |$|{}, ['fullPath', 'appendPath', 'header']|,$contextObj]);
      };
      $setContext("payload", $response);
      )
  - name: buildingResponse
    template: |
      (
        {
            "body": {
              "JSON": $context.payload.body ? $context.payload.body : {} ,
              "JSON_ARRAY": {},
              "XML": {},
              "FORM": {}
            },
            "version": "1",
            "type": "REST",
            "userId": message.anonymousId,
            "method": $context.payload.method ? $context.payload.method : 'POST' ,
            "endpoint": $context.finaleEndpoint,
            "headers": $context.finalHeaders ,
            "params": $context.payload.params ? $context.payload.params : {},
            "files": {}
          }

      )
      
      